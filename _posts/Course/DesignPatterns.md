---
title: 设计模式学习
date: 2022-05-15 15:08:04
tags:
- 课程
---

# 1. 面向对象的设计原则

SOLID指代了**面向对象编程**和**面向对象设计**的五个基本原则

| 名称        | 缩写  | 全称                                  | 解释                  |
| --------- | --- | ----------------------------------- | ------------------- |
| 单一职责原则    | SRP | Single Responsibility Principle     | 每个类的职责单一            |
| 开闭原则      | OCP | Open Closed Principle               | 类的改动，建议增加代码，不建议修改源码 |
| 里氏替换原则    | LSP | Liskov Substitution Principle       | 多态                  |
| 接口隔离原则    | ISP | Interface Segregation Principle     | 接口隔离                |
| 依赖倒置原则    | DIP | Dependence Inversion Principle      | 依赖抽象接口              |
| 迪米特法则     | LoD | Law of Demeter                      | 一个对象应当对其他对象少了解      |
| 组合/聚合复用原则 | CRP | Composite/Aggregate Reuse Principle | 继承不好，组合好的           |

总体原则：高聚合，低耦合
# 6.迪米特法则
解释：
去公司找人修电脑，不应该去找某个具体的小李、小张来修，应该抽象出一个接口类，IT部门，找IT部门修，用抽象接口再去对接实际的类，不然找小张解决不了问题，找小李解决不了问题。
结论：迪米特法则强调了类之间的松耦合关系，类之间的耦合越松，越有利于复用。

# 2. 设计模式的分类

1. 创建型模式（Creational Pattern）5种
   1. 工厂模式
   2. 抽象工厂模式
   3. 单例模式
   4. 建造者模式
   5. 原型模式
2. 结构型模式（Structural Pattern）7种
   1. 适配器模式
   2. 装饰者模式
   3. 代理模式
   4. 外观模式
   5. 桥接模式（Bridge Pattern）
   6. 组合模式
   7. 享元模式（Flyweight Pattern）
3. 行为型模式（Behavioral Pattern）11种
   1. 策略模式
   2. 模板方法模式
   3. 观察者模式
   4. 迭代器模式
   5. 责任链模式
   6. 命令模式
   7. 备忘录模式
   8. 状态模式
   9. 访问者模式
   10. 中介者模式
   11. 解释器模式


# 3. 设计模式的具体介绍

## 3.1 创建型模式（Creational Pattern）
### 3.1.1 简单工厂模式
#### 概述：
本来每个类都需要new出来，现在是通过一个工厂来创建
#### 优点：
1. 客户端和具体实现类解耦
2. 对于某些对象创建过程比较复杂情况，我们不用考虑这些了
#### 缺点：
1. 简单工厂模式，增加新的功能是通过修改源代码实现，不符合开闭原则
2. 这个类职责过重，这个类发生问题，会影响很多实用这个工厂的模块
#### 使用场景：
1. 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中个的业务逻辑太过复杂。
2. 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。
**解释**：用在不需要关心创建过程，读取什么文件，什么什么的，就想要用这个类
比如创建过程很复杂，但是我只是想用这个类，那我就用这个简单工厂创建一下就行，具体的创建过程都放在工厂里面





### 3.1.2 工厂模式
#### 概述：
对于每一个类，都对应一个具体创建的工厂类，然后再定义一个抽象工厂作为接口
简单工厂模式 + “开闭原则” = 工厂方法模式
#### 优点：
1. 不需要记住具体类名，甚至连具体参数都不用记忆（因为用的是抽象的工厂接口）
2. 实现了对象创建和使用的分离。
3. 系统的可扩展性也就变得非常好，无需修改接口和原类。（符合开闭原则）
#### 缺点：
1. 增加系统中类的个数，复杂度和理解度增加。
2. 增加了系统的抽象性和理解难度。
#### 适用场景
1. 客户端不知道它所需要的对象的类。
2. 抽象工厂类通过其子类来指定创建哪个对象。



工厂在这里面起的作用，就是隐藏了创建过程的复杂度，以配合InterfaceA对那一百个子类的复杂度进行隐藏，这样B只要知道上转型之后的InterfaceA即可，简单清晰。


## 3.2 结构型模式（Structural Pattern）


### 3.2.1 桥接模式

#### 概述：
桥接模式(Bridge),将抽象部分与它的实现部分分离，使他们都可以独立的变化。什么叫抽象与他的实现分离，这并不是说让抽象类与其派生类分离，因为这没有任何意义。实现指的是抽象类和它的派生类用来实现自己的对象。
#### 优点：
分离抽象接口及其实现部分。

桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。

桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。

实现细节对客户透明，可以对用户隐藏实现细节。
#### 缺点：
桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。
#### 适用场景



## 3.3 行为型模式（Behavioral Pattern）





# 参考资料
[weixin_42636062的博客 C++设计模式](https://blog.csdn.net/weixin_42636062/category_11313224.html)
[桥接模式（c++实现） ](https://www.cnblogs.com/wzxNote/p/12917281.html)
[C++享元模式探索：轻松优化内存使用和性能提升之道](https://developer.aliyun.com/article/1463784)
[设计模式在前端开发中的实践（三）——享元模式](https://juejin.cn/post/7323048733787226152?searchId=202411261635595727A47103E59B9498EF)
[备受“冷落”的享元模式](https://juejin.cn/post/7242911173723979833?searchId=202411261635595727A47103E59B9498EF)
[接口与实现分离](https://www.cnblogs.com/Stultz-Lee/p/10099261.html)













































